<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <!-- Prerequisites and setup tab -->
    <div>
        <h2>Prerequisites and Setup</h2>
        <p>This template demonstrates interaction from a spray web application with Memcached and therefore requires it to be installed.</p>
        <p>Go to <a href="http://memcached.org/">memcached.org</a> to install
					the correct version for your operating system. To ensure that it is
					up and running, you can try telneting to it.
					<pre>
						<code>
						telnet localhost 11211
						</code>
					</pre>
				</p>
				<p>Although the default configuration points to localhost
					and port 11211 for the Memcached server, you can change this default
					configuration in the <a
							href="#code/src/main/resources/application.conf"
							class="shortcut">application.conf</a> file. The <code>hosts</code>entry
					nested under <code>memcached</code> accepts a list of strings in the
					format of <code>"host:port"</code>. Change this variable to point to one or more
					other memcached instances.</p> 
    </div>

    <!-- General Overview -->
    <div>
        <h2>General Overview</h2>
        <p>This template uses spray-can to create a basic RESTful interface. If you run the application you can go to <a href="http://localhost:8080/profile">localhost:8080/profile</a> to see a simple JSON response for the service</p>
        <p>The <a href="#code/src/main/scala/rest/ProfileServiceComponent.scala" class="shortcut">ProfileServiceComponent</a> class is where we define the Profile route and add a few endpoints</p>
        <p></p>
    </div>

		<div>
			<h2>Using Memcached</h2>
			<p>To see how Memcached is being used with the app, take a look at the <a
						href="#code/src/main/scala/rest/ProfileServiceComponent.scala"
						class="shortcut">routes</a> again. Caching is done via the <a
								href="http://spray.io/documentation/1.0.1/spray-routing/caching-directives/cache/"
								>cache directive</a>. The cache directive accepts an
						implementation of a Spray cache which usually references the default
						<code>LruCache</code>. However, this template provides a custom
						implementation of a Spray cache: the <a
								href="#code/src/main/scala/com/credera/cache/MemcachedCache.scala"
								class="shortcut">Memcache Cache</a>. The basic idea is the same
						as the LruCache implementation, except that we use Memcached instead
						of a ConcurrentHashMap for storing entries.</p>
			<p>Now lets look at Memcache in action. First make get request for all
				profiles. <code>curl localhost:8080/profile</code>.  You should get a
				response and in your console you should see a note that the database has
			been accessed to fulfill the request.  If you don't see a note, you might
		already have a cache entry in memcache, in which case you can restart
		memcache to clear it. Now if you repeat the request, you should not see
		another statement in the log mentioning that the request was fulfilled from
		memcache.</p>

	<p>To force the response of the server, you can include an http header to
		invalidate the cache. To perform this using curl, you can use the following
		command: <code>curl -ivH 'Cache-Control:max-age=0'
			localhost:8080/profile</code>.  You should notice that the cache is not
		used when fulfilling the request.</p>

		</div>
    <div>
        <h2>Slick Integration</h2>

        <p>In the <a href="#code/src/main/scala/dao/ProfileDAOComponent.scala" class="shortcut">ProfileDAOComponent</a> is
            the persistence logic. This template loads an H2 database into memory and employs Slick to read and write
            profile information to it.</p>

        <p>By defining a <a href="#code/src/main/scala/h2/Profiles.scala" class="shortcut">Profiles</a> table you can link
            to the data stored in H2 and run queries against it</p>
    </div>
</body>
</html>
